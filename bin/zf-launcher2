#!/bin/bash
# zf-launcher2.sh
# A robust file launcher using fd, fzf, bat, and yq.
# This script is designed to be configured via a YAML file.

set -euo pipefail

# --- Dependency and Configuration Check ---

# 1. Check for required commands
check_dependencies() {
  local missing_deps=0
  local deps=($@)
  for cmd in "${deps[@]}"; do
    if ! command -v "$cmd" &>/dev/null; then
      echo "❌ Error: Required command '$cmd' is not installed." >&2
      missing_deps=1
    elif [ "$cmd" = "yq" ]; then
      # Check if yq is go-yq (mikefarah/yq)
      if ! yq --version 2>/dev/null | grep -q "mikefarah"; then
        echo "❌ Error: yq is not the required go-yq (mikefarah/yq). Please install go-yq." >&2
        missing_deps=1
      fi
    fi
  done
  if [ "$missing_deps" -eq 1 ]; then
    echo "Please install the missing dependencies and try again." >&2
    exit 1
  fi
}

# Define all dependencies here
REQUIRED_COMMANDS=("yq" "fzf" "fd" "bat")
check_dependencies "${REQUIRED_COMMANDS[@]}"

# 2. Locate and load configuration
CONFIG_FILE="$HOME/.config/zf-launcher/config.yaml"

# Create a default config if it doesn't exist
if [[ ! -f "$CONFIG_FILE" ]]; then
  echo "🔍 Configuration file not found. Creating a default one at $CONFIG_FILE"
  mkdir -p "$(dirname "$CONFIG_FILE")"
  cat >"$CONFIG_FILE" <<'EOF'
# ~/.config/zf-launcher/config.yaml
terminal:
  name: kitty
  # Available: kitty, alacritty, wezterm, foot

search:
  base_path: ~
  exclude:
    - .cache
    - node_modules
    - .git
    - target
    - build
    - dist
    - .next
    - __pycache__
    - .venv
  include_hidden: true
  file_types:
    - f # files
    - d # directories

fzf:
  preview:
    enabled: true
    position: right
    size: 50%
    window_options: "border-rounded"
  layout:
    height: 80%
    border: rounded
    margin: 1
    padding: 1
  keybindings:
    toggle_preview: "ctrl-p"
    select_all: "ctrl-a"
    deselect_all: "ctrl-d"

# Multi-editor configuration
editor:
  primary:
    command: code
    flags:
      - "--new-window"
      - "%F"
    label: "VS Code"
  
  secondary:
    command: zeditor
    flags:
      - "--new"
      - "%F"
    label: "Zed"
  
  # Fallback editor
  fallback: nvim

ui:
  show_progress: true
  show_terminal_info: true
  icons:
    directory: "📁"
    file: "📄"
    success: "✅"
    error: "❌"
    loading: "🔍"
    editor: "✎"

logging:
  enabled: true
  level: info
  file: /tmp/zf-launcher.log
EOF
  echo "✅ Default configuration created."
fi

# --- Parse Configuration using yq ---

# Function to safely parse YAML values
yq_get() {
  yq e "$1" "$CONFIG_FILE"
}

# Terminal
TERMINAL=$(yq_get '.terminal.name')

# Search parameters
SEARCH_PATH=$(yq_get '.search.base_path' | sed "s|~|$HOME|") # Expand ~
INCLUDE_HIDDEN=$(yq_get '.search.include_hidden')
mapfile -t EXCLUDE_PATHS < <(yq_get '.search.exclude[]')
mapfile -t FILE_TYPES < <(yq_get '.search.file_types[]')

# FZF parameters
PREVIEW_ENABLED=$(yq_get '.fzf.preview.enabled')
PREVIEW_POSITION=$(yq_get '.fzf.preview.position')
PREVIEW_SIZE=$(yq_get '.fzf.preview.size')
PREVIEW_WINDOW_OPTS=$(yq_get '.fzf.preview.window_options')
FZF_HEIGHT=$(yq_get '.fzf.layout.height')
FZF_BORDER=$(yq_get '.fzf.layout.border')
FZF_MARGIN=$(yq_get '.fzf.layout.margin')
FZF_PADDING=$(yq_get '.fzf.layout.padding')
mapfile -t FZF_KEYBINDINGS < <(yq e '[.fzf.keybindings | to_entries[] | .key + ":" + .value] | .[]' "$CONFIG_FILE")

# Editor parameters - Multi-editor support
declare -A EDITORS_CMD
declare -A EDITORS_FLAGS
declare -A EDITORS_LABEL
declare -a EDITOR_KEYS

# Read all available editors (primary, secondary, tertiary)
for key in $(yq_get '.editor | keys[]'); do
  if [[ "$key" != "fallback" ]]; then
    cmd=$(yq_get ".editor.$key.command")
    label=$(yq_get ".editor.$key.label" 2>/dev/null || echo "$key")
    
    EDITORS_CMD["$key"]="$cmd"
    EDITORS_LABEL["$key"]="$label"
    EDITOR_KEYS+=("$key")
    
    # Read flags for this editor
    mapfile -t flags_array < <(yq_get ".editor.$key.flags[]")
    EDITORS_FLAGS["$key"]=$(printf '%q ' "${flags_array[@]}")
  fi
done

EDITOR_FALLBACK=$(yq_get '.editor.fallback')

# UI Icons
ICON_DIR=$(yq_get '.ui.icons.directory')
ICON_FILE=$(yq_get '.ui.icons.file')
ICON_LOADING=$(yq_get '.ui.icons.loading')
ICON_EDITOR=$(yq_get '.ui.icons.editor' 2>/dev/null || echo "✎")

# --- Build Commands Dynamically ---

# 1. Build `fd` command arguments
declare -a FD_ARGS
if [[ "$INCLUDE_HIDDEN" == "true" ]]; then
  FD_ARGS+=("--hidden")
fi
for path in "${EXCLUDE_PATHS[@]}"; do
  FD_ARGS+=("--exclude" "$path")
done
for ftype in "${FILE_TYPES[@]}"; do
  FD_ARGS+=("--type" "$ftype")
done

# 2. Build `fzf` preview command
# This function will be exported to be available inside fzf's preview shell
# This avoids creating a temporary script file.
generate_preview() {
    local path="$1"
    if [ -d "$path" ]; then
        echo "${ICON_DIR} Directory: $path
"
        echo "────────────────────────────────────────
"
        echo "📊 Contents:
"
        ls -lah "$path" 2>/dev/null | head -15
        echo "
"
        echo "🗂️  Subdirectories:
"
        find "$path" -maxdepth 1 -type d 2>/dev/null | tail -n +2 | head -5
        echo "
"
        echo "📄 Files:
"
        find "$path" -maxdepth 1 -type f 2>/dev/null | head -5
    else
        echo "${ICON_FILE} File: $path
"
        local file_type
        file_type=$(file --mime-type "$path" 2>/dev/null | cut -d: -f2 | xargs)
        echo "🏷️  Type: $file_type
"
        echo "📏 Size: $(du -h "$path" 2>/dev/null | cut -f1)
"
        echo "📅 Modified: $(stat -c %y "$path" 2>/dev/null | cut -d. -f1)
"
        echo "────────────────────────────────────────
"
        
bat --color=always \
            --style=header,grid,numbers \
            --line-range=:100 \
            --theme=ansi \
            "$path" 2>/dev/null || head -50 "$path" 2>/dev/null
    fi
}

# Export the function and necessary variables so fzf's subshell can see them
export -f generate_preview
export ICON_DIR ICON_FILE

# 3. Build `fzf` command arguments
declare -a FZF_ARGS
FZF_ARGS+=(
  "--height=$FZF_HEIGHT"
  "--border=$FZF_BORDER"
  "--margin=$FZF_MARGIN"
  "--padding=$FZF_PADDING"
  "--prompt=${ICON_LOADING} "
  "--pointer=▶"
  "--marker=✓"
  "--info=inline"
  "--header=Press Ctrl+P to toggle preview | Ctrl+A to select all | Ctrl+D to deselect all"
)
if [[ "$PREVIEW_ENABLED" == "true" ]]; then
  FZF_ARGS+=("--preview=bash -c 'generate_preview "{}"'")
  FZF_ARGS+=("--preview-window=$PREVIEW_POSITION:$PREVIEW_SIZE:$PREVIEW_WINDOW_OPTS")
fi
# Add keybindings with proper fzf syntax
FZF_ARGS+=(
  "--bind=ctrl-p:toggle-preview"
  "--bind=ctrl-a:select-all"
  "--bind=ctrl-d:deselect-all"
)

# --- Execute ---

# Export functions and variables for use in the terminal subprocess
export -f generate_preview
export ICON_DIR ICON_FILE ICON_EDITOR

# Export editor configuration for use in the terminal subprocess
export CONFIG_FILE
for key in "${EDITOR_KEYS[@]}"; do
  export "EDITOR_${key}_CMD=${EDITORS_CMD[$key]}"
  export "EDITOR_${key}_FLAGS=${EDITORS_FLAGS[$key]}"
  export "EDITOR_${key}_LABEL=${EDITORS_LABEL[$key]}"
done
export EDITOR_FALLBACK
export SEARCH_PATH

# Create the script that will run inside the terminal
TERMINAL_SCRIPT=$(cat <<'SCRIPT_END'
# File selection with fzf
FD_ARGS_STR="__FD_ARGS__"
FZF_ARGS_STR="__FZF_ARGS__"

selected=$(cd "$SEARCH_PATH" && eval "fd $FD_ARGS_STR ." | eval "fzf $FZF_ARGS_STR")

if [ -z "$selected" ]; then
  echo "No file selected" >&2
  exit 0
fi

full_path="$SEARCH_PATH/$selected"

# Find available editors
EDITOR_KEYS_STR="__EDITOR_KEYS__"
IFS=' ' read -ra EDITOR_KEYS <<< "$EDITOR_KEYS_STR"

available_editors=()
for key in "${EDITOR_KEYS[@]}"; do
  cmd_var="EDITOR_${key}_CMD"
  cmd="${!cmd_var}"
  if command -v "$cmd" &>/dev/null; then
    available_editors+=("$key")
  fi
done

# Select editor
if [ ${#available_editors[@]} -eq 0 ]; then
  if command -v "$EDITOR_FALLBACK" &>/dev/null; then
    selected_editor="fallback"
  else
    echo "❌ Error: No editors available" >&2
    read -p "Press Enter to close..."
    exit 1
  fi
elif [ ${#available_editors[@]} -eq 1 ]; then
  selected_editor="${available_editors[0]}"
else
  # Multiple editors - show selection menu
  editor_menu=""
  for key in "${available_editors[@]}"; do
    label_var="EDITOR_${key}_LABEL"
    label="${!label_var}"
    editor_menu="${editor_menu}${key}:${label}"$'\n'
  done
  
  selected_line=$(echo -n "$editor_menu" | fzf \
    --height=20% \
    --border=rounded \
    --prompt="${ICON_EDITOR} Select Editor: " \
    --pointer="▶" \
    --marker="✓" \
    --no-multi \
    --with-nth=2 \
    --delimiter=: \
    --exit-0)
  
  if [ -z "$selected_line" ]; then
    echo "No editor selected" >&2
    exit 0
  fi
  
  selected_editor=$(echo "$selected_line" | cut -d: -f1)
fi

# Launch editor
if [ "$selected_editor" = "fallback" ]; then
  echo "🚀 Opening with: $EDITOR_FALLBACK" >&2
  "$EDITOR_FALLBACK" "$full_path" &
else
  label_var="EDITOR_${selected_editor}_LABEL"
  cmd_var="EDITOR_${selected_editor}_CMD"
  flags_var="EDITOR_${selected_editor}_FLAGS"
  
  label="${!label_var}"
  cmd="${!cmd_var}"
  flags_str="${!flags_var}"
  
  echo "🚀 Opening with: $label" >&2
  
  # Parse flags
  eval "flags_array=($flags_str)"
  final_args=()
  path_inserted=false
  
  for flag in "${flags_array[@]}"; do
    if [[ "$flag" == "%F" ]]; then
      final_args+=("$full_path")
      path_inserted=true
    else
      final_args+=("$flag")
    fi
  done
  
  if ! $path_inserted; then
    final_args+=("$full_path")
  fi
  
  "$cmd" "${final_args[@]}" &
fi

# Wait for editor to start, then close terminal
sleep 0.5
echo "✅ Editor launched successfully" >&2
SCRIPT_END
)

# Replace placeholders in the script
FD_ARGS_QUOTED=$(printf "%q " "${FD_ARGS[@]}")
FZF_ARGS_QUOTED=$(printf "%q " "${FZF_ARGS[@]}")
EDITOR_KEYS_STR="${EDITOR_KEYS[*]}"

TERMINAL_SCRIPT="${TERMINAL_SCRIPT//__FD_ARGS__/$FD_ARGS_QUOTED}"
TERMINAL_SCRIPT="${TERMINAL_SCRIPT//__FZF_ARGS__/$FZF_ARGS_QUOTED}"
TERMINAL_SCRIPT="${TERMINAL_SCRIPT//__EDITOR_KEYS__/$EDITOR_KEYS_STR}"

# Execute in terminal
case "$TERMINAL" in
  kitty)
    kitty --title "zf-launcher" bash -c "$TERMINAL_SCRIPT"
    ;;
  alacritty)
    alacritty --title "zf-launcher" -e bash -c "$TERMINAL_SCRIPT"
    ;;
  wezterm)
    wezterm start --title "zf-launcher" -- bash -c "$TERMINAL_SCRIPT"
    ;;
  foot)
    foot --title "zf-launcher" bash -c "$TERMINAL_SCRIPT"
    ;;
  *)
    echo "⚠️ Warning: Unsupported terminal '$TERMINAL' in config. Trying to run in current environment." >&2
    if [[ -t 0 ]]; then
      bash -c "$TERMINAL_SCRIPT"
    else
      echo "❌ Error: Cannot launch fzf because this script is not running in a terminal." >&2
      echo "   Please configure a supported terminal (kitty, alacritty, wezterm, foot) in '$CONFIG_FILE'." >&2
      exit 1
    fi
    ;;
esac
